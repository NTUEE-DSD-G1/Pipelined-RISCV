# DSD Pipeline RISCV report #

Group 3: b07901021 潘世軒、b07901036 陳俊廷、b07901137 吳陽禾

## Baseline ##

## Extension ##

### Branch Prediction ###

#### (a) Design methodology for good score (before/after) ####

![image-20210612161556468](C:\Users\潘軒\AppData\Roaming\Typora\typora-user-images\image-20210612161556468.png)

上圖是我加入Branch Prediction Unit 的電路簡圖(僅畫到ID stage)，基本上大部分的邏輯和設計都和pdf裡面要求的spec相同，以下就一些我有特別設計的巧思或是一些比較值得提的部分進行說明。

1. BPU

   這次的Pipelined CPU支援的branch指令包含beq和bne，當我在設計BPU的時候我就在想如果有兩種branch的指令，是要將兩者的BPU分開設計還是有什麼辦法可以合在一起做，後來我想了BPU的功能主要是透過把Program Counter跳轉的時機從ID stage轉到IF stage來省下一個stalled cycle，就算預測失敗，也只要在ID stage把錯誤的instruction flush掉就好，其主要功能就是當我一連串的instruction出現loop的時候，能透過prediction來省下cycle數。而當我們遇到loop的時候loop中的branch指令都會是同種，因此在最後我的設計是將beq和bne的BPU合併，BPU預測的是branch指令會不會taken (e.g.會不會跳到PC+imm的address)，而不是預測是否兩個待測的數值相同。這樣設計可以多省下一個BPU的面積(相較替兩種branch指令都設計一個BPU)，同時也能達到Branch prediction unit的功能。

   下圖是BPU的state diagram，主要是用2-bit predictor來實作，這樣的predictor在預測迴圈中只有一個branch指令的時候、或者迴圈中除了控制跳轉的branch指令之外還有一個不一定發生的branch指令能夠達到良好的成效。(詳細會在part(d)進行討論)

   ![image-20210612163915902](C:\Users\潘軒\AppData\Roaming\Typora\typora-user-images\image-20210612163915902.png)

2. Jal 

   Jal指令的功能是將next_PC設為PC+imm，並將PC+4存到指定的reegister中，有別於Jalr必須從Regfile中讀出RS1的值後才能計算，Jal只要PC和imm就能進行計算，其實有點像是一定會跳轉的branch指令，因此我選擇將Jal的計算也從ID移到IF stage來做計算，只要從Icache中讀出Jal指令，就會將next_PC設成PC+imm(如上方電路圖的左上角)。

3. Hazard Modification

   在做Baseline的時候，我們為了減少critical path 將下方情況做了中間stall一個cycle的改進，但在此處，由於crtical path會變成 Icache

   ```assembly
   addi x11 x11 0x001  
   beq  x8  x11 0x004 
   ```

   

#### (b) The relationship between design BPU and parameter size for generating test program ####

#### (c) What you have learned? ####

#### (d) Other detailed discussion ####

### Compression ###

### L2 Cache ###



